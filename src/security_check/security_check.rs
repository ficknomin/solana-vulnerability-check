use syn::{File,Item, ItemFn, Lit};
use syn::spanned::Spanned;
use syn::visit::{self, Visit};
use syn::{Stmt, Expr, BinOp};
use crate::security_rules::security_rules::RulesRegistry;
use crate::security_rules::security_rules::Severity;

pub struct SecurityRuleChecker<'ast> {
    pub security_rules: &'ast RulesRegistry,
    pub line_num: usize,
    pub func_name: String,

}
impl<'ast> Visit<'ast> for SecurityRuleChecker<'ast> {
    fn visit_file(&mut self, file: &'ast File) {
        visit::visit_file(self, file);
    }

    fn visit_item_fn(&mut self, item_fn: &'ast ItemFn) {
        self.func_name = item_fn.sig.ident.to_string(); // Capture function name
        visit::visit_item_fn(self, item_fn);
    }
    fn visit_stmt(&mut self, stmt: &'ast Stmt){
        self.line_num += 1;
        visit::visit_stmt(self, stmt);
    }
    fn visit_expr(&mut self, expr: &'ast Expr){
        self.line_num += 1;
        
        //checking every expression against all the security patterns
        for rule in &self.security_rules.rules{
            match rule.pattern{
                "unchecked_arithmetic_operation" => {
                    self.check_arithmetic_operator(expr, &rule.severity);
                }

                "loss_of_precision" => {
                    self.check_loss_of_precision(expr, &rule.severity);
                }

                "division_by_zero" =>{
                    self.check_division_by_zero(expr, &rule.severity)
                }
                _ => {}
            }
        }
        visit::visit_expr(self, expr);
    }
}

impl<'ast> SecurityRuleChecker<'ast>{
    pub fn new(security_rules: &'ast RulesRegistry) -> Self {
        SecurityRuleChecker {
            security_rules,
            line_num: 0,
            func_name: String::new(), // Initialize with an empty string
        }
    }

    fn check_arithmetic_operator(&self, expression: &'ast Expr, severity: &Severity){
        if let Expr::Binary(binary_expr) = expression{
            if matches!(binary_expr.op, BinOp::Add(_) | BinOp::Sub(_)){
                println!(
                    "Potential vulnerability at function {}, Severity: {:?}, {}",
                    self.func_name, severity,
                    "Integer overflow/underflow possible (use checked_add/checked_sub)",
                );
            }
        }
    }

    fn check_loss_of_precision(&self, expression: &'ast Expr, severity: &Severity) {
        if let Expr::MethodCall(method_call) = expression {
            if method_call.method == "try_round_u64" {
                println!(
                    "Potential vulnerability at function {}, Severity: {:?}, {}",
                    self.func_name, severity,
                    "Loss of precision detected: try_round_u64() may lead to precision issues. Try using try_floor_u64() instead.",
                );
            }
        }
    }

    fn check_division_by_zero(&self, expression: &'ast Expr, severity: &Severity) {
        if let Expr::Binary(binary_expr) = expression {
            if let BinOp::Div(_) = binary_expr.op {
                // We need to check if the divisor could potentially be zero. If the divisor is a literal
                if let Expr::Lit(expr_lit) = &*binary_expr.right {
                    if let Lit::Int(lit_int) = &expr_lit.lit {
                        if lit_int.base10_parse::<u64>().unwrap() == 0 {
                            println!(
                                "Potential division by zero at function {}, Severity: {:?}, {}",
                                self.func_name, severity,
                                "Division by zero can cause the program to panic. Make sure the divisor isn't zero.",
                            );
                        }
                    }
                }
                // More checks for when the divisor is a variable
                
            }
        }
    }
}